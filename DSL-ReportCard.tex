\documentclass[11pt]{article}

\usepackage{mathptmx,amssymb,amsmath}
\usepackage{fullpage}
\usepackage{enumerate}
\usepackage{fancyvrb}
\usepackage{listings}             % Include the listings-package
\usepackage{color}
\usepackage{courier}
\usepackage{multicol}
\usepackage{lipsum}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%
%%% Formatting details
%%%
\sloppy
\sloppypar
\widowpenalty=0
\clubpenalty=0
\displaywidowpenalty=0
\raggedbottom
\pagestyle{plain}


% \topskip0pt
% \parskip0pt
% \partopsep0pt

\DefineVerbatimEnvironment{program}{Verbatim}
  {baselinestretch=1.0,xleftmargin=5mm,fontsize=\small,samepage=true}

\def\denseitems{
    \itemsep1pt plus1pt minus1pt
    \parsep0pt plus0pt
    \parskip0pt\topsep0pt}


%%%
%%% A few macros
%%%
\newcommand{\RevisionNeeded}{\bigskip\noindent\fbox{
\textbf{Be prepared to revise this section \emph{many} times!}}}

\newcommand{\prog}[1]{{\small\texttt{#1}}}
% \newcommand{\bs}{\texttt{\symbol{92}}}



\begin{document}

\title{\textbf{DSL for Software Configuration Management}
\\ DSL Report Card}

\author{Sergii Shmarkatiuk \\
School of EECS \\ 
Oregon State University
}

\maketitle


\section{Introduction}
\label{sec:intro}

\textbf{Domain}: Software Configuration Management (SCM). SCM domain includes such activities as \textit{version control}, \textit{build management}, \textit{deployment management}, \textit{continuous integration}, \textit{release management}, \textit{dependencies management}, \textit{branch management} and \textit{merge management}. Mentioned activities have one important thing in common - they use version numbers as unique references to software artifacts. Even though version numbers are widely used, certain problems with version numbering approaches that inhibit development of general purpose tools for SCM. Most common problems with version numbering are:
\begin{enumerate}
 \item Version numbers if may not necessarily be unique. 
 \item Version numbering approaches are not formalized to an extent that would allow embedding automatic version numbering into commonly used SCM tools (for example, version control systems).
 \item Very often there is an attempt to use version numbers to represent different kinds of changes between different artifacts, but existing practices of assigning meaning to version numbers are far from consistent (change depending on context and different situations) and cannot be reliably used to represent meaning of version numbers.
\end{enumerate}

Main goals of DSL for Software Configuration Management is to:
\begin{itemize}
 \item Introduce unambiguous version numbering formalization.
 \item Extend formalized version numbering approach with additional constructs (such as maturity levels, artifact trees) to cover common Software Configuration Management use cases.
 % \item Providing interface for mapping "old style" version numbering to consistent version numbering implemented as a DSL for SCM.
 \item Provide common patterns for generation of verbal description for software artifact based on its version number and context in an artifact tree. 
 \end{itemize} 

One of the most advanced version numbering approaches is SemVer \cite{semver}. While strength of this approach is simplicity, there are also serious limitations of SemVer, such as:
\begin{itemize}
\item Lack of formalization. There is only verbal description of SemVer approach available online. 
\item As long as there is no formal definition of version numbering approach by SemVer, there is no way to detect whether version number of specific artifact already exists. This often leads to assignment of ambiguous version numbers when one version number represents several different artifacts.
\item It introduces ambiguous rules (for example, composition of version numbers) that, if applied, result in unreliable references to software artifacts.
\end{itemize}

There is another approach that is similar to version numbering - \textit{document sections numbering approach}. TODO: describe advantages and limitations.

\section{Users}
\label{sec:users}

% How is the DSL going to be used, and what specifically is it used for?  
Primary audience of DSL for SCM is Release and Build Engineers. DSL for SCM can also be used by Software Engineers, Software Testing Engineers and Support Engineers given that users have enough knowledge both about SCM domain and about basic principles of the DSL for SCM. 

Release and Build Engineers are considered to be domain experts. Typical DSL for SCM operations for Release and Build Engineers are:
\begin{itemize}
\item Building \textit{trees of software artifacts} and their versions in order to track history of software releases and releases of software components 
\item Generation of \textit{new version numbers} for upcoming software packages and releases
\item Handling artifacts \textit{insertions} and \textit{renaming} of artifacts in artifact trees.
% \item Creation, application and reusing \textit{filters of version numbers} (version \textit{templates} and \textit{ranges})
%\item Managing \textit{dependencies} between different versions of software applications and software components. Building \textit{dependency graphs}.
%\item Building abstractions on top of DSL for SCM that represent \textit{Software Product Lines} (SPL).
%\item \textit{Development, testing and deployment of upgrades} for different software versions. 
%\item Refactor version numbers (map inconsistent and ambiguous version numbers to formalized version numbering) to get rid of limitations of version numbering approaches that were used previously.
\end{itemize}

% What kind of users are affected by the DSL and in which way? Who is writing programs and who is using them? What is known or can be reasonably assumed about the (technical/domain) background of users? (Usually, it is safe to assume that users are domain experts.)

% Specifically, what are the limitations of the DSL? What cannot be expressed? If different kinds of users are involved, what are there limitations of for the different user groups?

The most serious limitation of DSL for SCM is that it can be used only by users with domain expertise with proper training that ensures their understanding of basic principles of DSL for SCM. We left high-level abstraction on top of DSL for SCM that enables users with SQL-like declarative language for selection and manipulation on version sets for future work.

\section{Outcomes}
\label{sec:outcomes}

% What is (are) the outcome(s) of executing a DSL program? What analyses of DSL programs are conceivable?  Note that, in general, a DSL program can produce a variety of results. In fact, this aspect makes the use of a DSL very attractive, and this questions is an important part of the analysis of the DSL's purpose.

Typical output of DSL for SCM is \textit{artifact tree} that can be built given initial artifact tree and list of DSL operations (DSL program). 

% Another example of output that DSL for SCM can produce is a subset of version numbers created based on filters of version numbers.

Also new versions generated by DSL for SCM can be considered to be typical output of the program.

% Consider, for example, a DSL for describing vacation plans (including
% alternatives).  We can imagine that a vacation plan can be analyzed to yield a
% set of \emph{date/time ranges} for the vacation (based on the availability of
% flights, hotels, etc.), or a set of \emph{cost estimates} (based on travel and
% date options). Moreover, we can imagine deriving \emph{to-do lists} from the
% travel plan (making reservations, buying tickets, etc.) or \emph{entertainment
% suggestions} (parks, museums, events, etc.). 

% The outcomes should be made more precise in Section \ref{sec:analysis} in the form of function signatures once the basic objects and combinators have been identified in Sections \ref{sec:objects} and \ref{sec:comb}.

\section{Use Cases / Scenarios}
\label{sec:examples}

% Describe several typical example problems or use cases that can be expressed in the DSL. For each example, give a summary of what the example is about, and explain how important and representative it is for the domain.

There is very common problem of ambiguous reference to the latest version of software application or library. TODO: describe this use case

Another use case is deployment and redeployment of the web-site (TODO: use class page management as a motivating example)
\textbf{Available artifacts:}
\begin{enumerate}
\item Class syllabus
\item Class schedule 
\item Materials for the class (presentations, exercises, homeworks, solutions, etc)
\item Template of class page
\end{enumerate}

\textbf{TODO:}
\begin{itemize}
\item History of class page that can be reused in the future (next year)
\end{itemize}

\textbf{Steps:}
\begin{enumerate}
\item Allocate repository for class page (represented by \textbf{x}, or high-level concept of \textit{work in progress})
\item Add template of class page to the repository 
\item Commit existing version to the repository (first revision)
\item Fill in class page template with content 
\item Commit existing version to the repository (second revision)
\item Fill in class page with content for week 1 
\item Commit existing version to the repository (third revision)
\item Add presentation for week 1, commit (4th rev)
\item Add homework for week 1, commit  (5th rev)
\item Deploy to the server
\item Add solutions for homework 1, commit (6th rev)
\item Deploy to the server
\item ...
\end{enumerate}
% Then describe in more detail the steps involved in solving the problem (either
% by hand or with existing tools). This process can be very helpful in shedding
% light on what kind of basic objects, types, and combinators the DSL will have
% to offer.



\section{Basic Objects}
\label{sec:objects}

% What are the basic objects that are manipulated and used by the DSL? Basic
% objects are those that are not composed out of other objects. 

\lstdefinestyle{Haskell}
{
	language=Haskell,caption=Haskell,basicstyle=\footnotesize\ttfamily,breaklines=true,frame=single
}
\lstdefinestyle{Examples}
{
	language=Haskell,basicstyle=\footnotesize\ttfamily,breaklines=true,caption=Examples
}
\lstset{style=Haskell}          % Set your language (you can change the language for each code-block optionally)

\subsection{VersionCompound}

%\begin{lstlisting}[style=Haskell,caption=BNF]
%VersionCompound ::= X | Int
%\end{lstlisting}

\begin{lstlisting}[caption=Haskell]  % Start your code-block

data VersionCompound = NumberPlaceholder
                     | Number Int 
                     deriving (Show)
\end{lstlisting}
\begin{lstlisting}[caption=Examples,style=Examples]  % Start your code-block

NumberPlaceholder	
Number 1	
Number 2	
Number 45	
Number 67	
Number 1010145
\end{lstlisting}

\subsection{VersionNumber}

%\begin{lstlisting}[caption=BNF]
%VersionNumber ::= VersionCompound | VersionNumber VersionCompound
%\end{lstlisting}	

\begin{lstlisting}[style=Haskell]
data VersionNumber = VersionCompound VersionCompound
       | VersionNumber VersionCompound VersionNumber
       deriving (Show)
\end{lstlisting}

%\begin{table}[h]
%\begin{tabular}	{ |l|l| }
%\hline
	\begin{lstlisting}[style=Examples]
	VersionCompound (Number 5)
	VersionNumber NumberPlaceholder ( VersionCompound NumberPlaceholder) 
	VersionNumber (Number 3) ( VersionCompound (Number 1) )
	VersionNumber NumberPlaceholder (VersionNumber NumberPlaceholder ( VersionCompound (Number 6) ) )	
	\end{lstlisting}

\subsection{MaturityLevel}

%\begin{lstlisting}[caption=BNF]			    
%MaturityLevel ::= MaturityLevelBuild | MaturityLevelRelease	 
%\end{lstlisting}	

%\begin{lstlisting}[caption=BNF]			    
%MaturityLevel ::= Dev | Test | User | ReleaseCandidate | Stable
%\end{lstlisting}	

%\begin{lstlisting}
%
%data MaturityLevel = Build MaturityLevelBuild
%                   | Release MaturityLevelRelease
%                   deriving (Show)
%
%\end{lstlisting}
\begin{lstlisting}[style=Haskell]
data MaturityLevel = Dev
                   | Test
                   | User
                   | ReleaseCandidate
                   | Stable
                   deriving (Show)
\end{lstlisting}

%\begin{lstlisting}[style=Examples]
%	Build Dev
%	Build Test
%	Release Test
%	Build User
%	Release User
%	Release ReleaseCandidate
%	Release	Stable
%\end{lstlisting}
\begin{lstlisting}[style=Examples]
	Dev
	Test
	User
	ReleaseCandidate
	Stable
\end{lstlisting}

\subsection{Version}

%\begin{lstlisting}[caption=BNF]
%Version ::= MaturityLevel VersionNumber
%\end{lstlisting}

\begin{lstlisting}[style=Haskell]
data Version = MaturityVersion MaturityLevel VersionNumber  
			| Version VersionNumber
\end{lstlisting}

\begin{lstlisting}[style=Examples]
Version (VersionCompound (Number 1))
MaturityVersion Dev (VersionNumber NumberPlaceholder (VersionCompound (Number 1)))
MaturityVersion ReleaseCandidate (VersionNumber (Number 2) (VersionCompound (Number 1)))
\end{lstlisting}

\subsection{DocumentOrDirectory}
\begin{lstlisting}[style=Haskell]
type DocumentName = String
type DirectoryName = String
type DocumentContent = String

data Document = Document DocumentName DocumentContent deriving (Eq)
data Directory = Directory DirectoryName [DocumentOrDirectory] deriving (Eq)
newtype DocumentOrDirectory = DocumentOrDirectory (Either Document Directory) deriving (Eq)
\end{lstlisting}

\begin{lstlisting}[style=Examples]
DocumentOrDirectory (Left (Document "documentName" "documentContents"))
DocumentOrDirectory (Right (Directory "directoryName" [DocumentOrDirectory (Left (Document "documentName" "documentContents"))] ))
\end{lstlisting}

\subsection{Artifact}
\begin{lstlisting}[style=Haskell]
type BranchName = String
type Timestamp = Integer

data Branch = Branch BranchName Version DocumentOrDirectory
data Snapshot = Snapshot Timestamp Version DocumentOrDirectory 
newtype Artifact = Artifact (Either Branch Snapshot) deriving (Show, Eq)
\end{lstlisting}

\begin{lstlisting}[style=Examples]
Branch "trunk" (Version (VersionCompound NumberPlaceholder)) (DocumentOrDirectory (Left (Document "documentName" "documentContents")))
Snapshot 1424012390 (Version (VersionCompound (Number 1))) (DocumentOrDirectory (Left (Document "documentName" "documentContents")))
Artifact ( Right (Snapshot 1424012390 (Version (VersionCompound (Number 1))) (DocumentOrDirectory (Left (Document "documentName" "documentContents")))))
\end{lstlisting}

\subsection{ArtifactTree}
We use object ArtifactTree to represent \textit{artifact trees} in our DSL.
\begin{lstlisting}[style=Haskell]
type ArtifactTree = RoseTree Artifact
\end{lstlisting}

\begin{lstlisting}[style=Examples]
initialArtifactTree :: ArtifactTree 
initialArtifactTree = RoseTree ( liftSnapshot $ (Snapshot 0 (Version $ VersionCompound (Number 0) ) ) ( liftDocument $ Document "" "") ) 
 [ RoseTree ( liftBranch $ (Branch "trunk" ( Version $ VersionCompound $ NumberPlaceholder ) ) (liftDocument $ Document "" "") ) [] ]
 
> displayArtifactTree initialArtifactTree
 
    0    
    |    
trunk (x)

\end{lstlisting}
% As a general rule, the fewer basic objects one needs, the better, because the resulting DSL design will be more concise and elegant.
%
% The basic objects should be described by a set of Haskell \prog{type} and
% \prog{data} definitions. Use the \prog{program} environment to show code, as
% illustrated below.

% \begin{program}
% type Point = (Int,Int)
% \end{program}
%
% Show how (some (parts) of) the examples from Section \ref{sec:examples} will be
% represented by values of the envisioned types. For example:

% \begin{program}
% home :: Point
% home = (10,13)
% \end{program}
 \begin{lstlisting}
initialArtifactTree :: ArtifactTree 
initialArtifactTree = RoseTree ( liftSnapshot $ (Snapshot 0 (Version $  VersionCompound (Number 0) ) ) ( liftDocument $ Document "" "") ) 
 [ RoseTree ( liftBranch $ (Branch "trunk" ( Version $ VersionCompound $ NumberPlaceholder ) ) (liftDocument $ Document "" "") ) [] ]
 
> displayArtifactTree initialArtifactTree 

    0    
    |    
trunk (x)
 
 program = generateSnapshot "trunk" >>> generateSnapshot "trunk" >>> createReleaseBranch "trunk"

 resultTree = program initialArtifactTree
 
> displayArtifactTree resultTree
 
        x.0        
         |         
    trunk (x.x)    
         |         
  ------------     
 /    |       \    
x.1  x.2     x.3   
              |    
          0.x (0.x)

 
 \end{lstlisting}
%
% Also, list current limitations that you expect in a future iterations to overcome.

% \RevisionNeeded

\subsection{Platform}
 \begin{lstlisting}
type PlatformName = String

data PlatformContents = PlatformContents DocumentOrDirectory Version BranchName
                deriving (Show)
 
data Platform = Platform PlatformName PlatformContents

type PlatformDB = [Platform]
 \end{lstlisting}
 
\subsection{DeploymentRule}

 \begin{lstlisting}
 data DeploymentRule = DeploymentRuleVersion Version PlatformName
                    | DeploymentRuleArtifact Artifact PlatformName
                    deriving (Show)
 
 type DeploymentRules = [DeploymentRule]

 \end{lstlisting}
 

\section{Operators and Combinators}
\label{sec:comb}

% Identify operators that either transform objects into one another or
% build more complex objects out of simpler (and ultimately basic) ones.
%
% Depending on what implementation or form of embedding will be chosen,
% operators may be given as constructors of data types or functions.

\begin{lstlisting}[style=Haskell]
generateSnapshot :: BranchName -> ArtifactTree -> ArtifactTree
\end{lstlisting}
\begin{lstlisting}[style=Haskell]
createExperimentalBranch :: BranchName -> ArtifactTree -> ArtifactTree
\end{lstlisting}
\begin{lstlisting}[style=Haskell]
createReleaseBranch :: BranchName -> ArtifactTree -> ArtifactTree
\end{lstlisting}
\begin{lstlisting}[style=Haskell]
createSupportBranch :: BranchName -> ArtifactTree -> ArtifactTree
\end{lstlisting}
\begin{lstlisting}[style=Haskell]
editArtifact :: BranchName -> DocumentOrDirectory -> ArtifactTree -> ArtifactTree
\end{lstlisting}
\begin{lstlisting}[style=Haskell]
deploy :: ArtifactTree -> DeploymentRules -> PlatformDB -> PlatformDB
\end{lstlisting}

% Combinators are higher-order functions that encode control structures of the
% DSL. The function \prog{map} is a combinator that realizes a looping construct
% for lists. The operations of the parser library Parsec are called \emph{parser
% combinators} since parsers themselves are represented as functions.
%
% The identification of the right set of combinators is a key step in the design
% of the DSL.

% With basic objects, operators, and combinators, you should be able to
% demonstrate how the examples from Section \ref{sec:examples} can be
% represented. All limitations encountered here should be classified as either:


\begin{enumerate}[(1)]\denseitems
\item \textbf{Temporary}. It is impossible to define deployment rules using syntax different than Haskell object definition syntax. For example: 
\begin{lstlisting}[style=Haskell]
deploymentRule = DeploymentRuleVersion ( Version ( VersionCompound $ Number 10 ) ) "platform1" 
\end{lstlisting}
Another temporary limitation of the DSL is the absence of error-handling. DSL does not generate meaningful errors in situations when incorrect input has been provided. 
\item \textbf{Fundamental}. Operators have long list of arguments with unclear order. Some of operators are incompatible with other operators. For example, it is impossible to chain \emph{deploy} operator with other operators. 
\end{enumerate}


%
% Temporary limitations should be noted in this section and in  Section
% \ref{sec:objects} as \emph{TO DO} items for future revisions of the design.
%
% Fundamental limitations should be reported and listed in detail in Section
% \ref{sec:users}.

% \RevisionNeeded



\section{Interpretation and Analyses}
\label{sec:analysis}
\subsection{High-level example}
In order to provide examples of interpretation and analyses in our DSL, we provide list of self-explanatory listings for executions of DSL programs: 
\begin{lstlisting}
initialArtifactTree :: ArtifactTree 
initialArtifactTree = RoseTree ( liftSnapshot $ (Snapshot 0 (Version $  VersionCompound (Number 0) ) ) ( liftDocument $ Document "" "") ) 
 [ RoseTree ( liftBranch $ (Branch "trunk" ( Version $ VersionCompound $ NumberPlaceholder ) ) (liftDocument $ Document "" "") ) [] ]
 
> displayArtifactTree initialArtifactTree 

    0    
    |    
trunk (x)
 \end{lstlisting}
 \begin{lstlisting}
 program = generateSnapshot "trunk" 
 
> displayArtifactTree (program initialArtifactTree)
 
    0    
    |    
trunk (x)
    |    
    1   
 
 \end{lstlisting}
 
 \begin{lstlisting}
 program = generateSnapshot "trunk" >>> generateSnapshot "trunk"
 
> displayArtifactTree (program initialArtifactTree)
 
    0    
    |    
trunk (x)
    |    
    --   
   /  \  
   1  2  
 
 \end{lstlisting}
 
  \begin{lstlisting}
 program = generateSnapshot "trunk" >>> generateSnapshot "trunk" >>> createReleaseBranch "trunk"
 
> displayArtifactTree (program initialArtifactTree)
 
        x.0        
         |         
    trunk (x.x)    
         |         
  ------------     
 /    |       \    
x.1  x.2     x.3   
              |    
          0.x (0.x)
 
 \end{lstlisting}
 \begin{lstlisting}
 program = generateSnapshot "trunk" >>> generateSnapshot "trunk" >>> createReleaseBranch "trunk" >>> createSupportBranch "trunk"
 
> displayArtifactTree (program initialArtifactTree)
 
                 x.x.0                  
                   |                    
             trunk (x.x.x)              
                   |                    
   ------------------------------       
  /      |         |             \      
x.x.1  x.x.2     x.x.3         x.x.4    
                   |             |      
              0.x (x.0.x)  0.x.x (0.x.x)

 
 \end{lstlisting}

\subsection{Specific example}
Another example uses list of steps from section \ref{sec:examples} to illustrate how DSL works in a specific sequence of SCM actions.
\begin{enumerate}
\item Allocate repository for class page (represented by \textbf{x}, or high-level concept of \textit{work in progress})
\begin{lstlisting}
initialArtifactTree :: ArtifactTree 
initialArtifactTree = RoseTree ( liftSnapshot $ (Snapshot 0 (Version $  VersionCompound (Number 0) ) ) ( liftDocument $ Document "" "") ) 
 [ RoseTree ( liftBranch $ (Branch "trunk" ( Version $ VersionCompound $ NumberPlaceholder ) ) (liftDocument $ Document "" "") ) [] ]
 
> displayArtifactTree initialArtifactTree 

    0    
    |    
trunk (x)
 \end{lstlisting}
\item Add template of class page to the repository
\begin{lstlisting}
program = editArtifactTree "trunk" (liftDocument $ Document "classPage" "") 

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: )) []]

> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)

\end{lstlisting}
\item Commit existing version to the repository (first revision)

\begin{lstlisting}
program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk"

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: )) [RoseTree (Artifact (Right Snapshot taken at 1, Version 1, Document name: classPage, Content: )) []]]


> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)
    |    
    1  

\end{lstlisting}

\item Fill in class page template with content 
\begin{lstlisting}
program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>") 

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>)) [RoseTree (Artifact (Right Snapshot taken at 1, Version 1, Document name: classPage, Content: )) []]]


> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)
    |    
    1 

\end{lstlisting}
\item Commit existing version to the repository (second revision)
\begin{lstlisting}
program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>") >>> 
generateSnapshot "trunk"

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>)) [RoseTree (Artifact (Right Snapshot taken at 1, Version 1, Document name: classPage, Content: )) [],RoseTree (Artifact (Right Snapshot taken at 2, Version 2, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>)) []]]


> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)
    |    
    --   
   /  \  
   1  2  

\end{lstlisting}
\item Fill in class page with content for week 1
 \begin{lstlisting}
program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk" >>> editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>")  

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>)) [RoseTree (Artifact (Right Snapshot taken at 1, Version 1, Document name: classPage, Content: )) [],RoseTree (Artifact (Right Snapshot taken at 2, Version 2, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>)) []]]


> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)
    |    
    --   
   /  \  
   1  2  

\end{lstlisting}
\item Commit existing version to the repository (third revision)
 \begin{lstlisting}
program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>") >>> 
generateSnapshot "trunk"  

> (program initialArtifactTree)

RoseTree (Artifact (Right Snapshot taken at 0, Version 0, Document name: , Content: )) [RoseTree (Artifact (Left Branch 'trunk', Version x, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>)) [RoseTree (Artifact (Right Snapshot taken at 1, Version 1, Document name: classPage, Content: )) [],RoseTree (Artifact (Right Snapshot taken at 2, Version 2, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>)) [],RoseTree (Artifact (Right Snapshot taken at 3, Version 3, Document name: classPage, Content: <html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>)) []]]


> displayArtifactTree (program initialArtifactTree)

    0    
    |    
trunk (x)
    |    
  -----  
 /  |  \ 
 1  2  3   

\end{lstlisting}
\item Deploy to the server (3rd revision)
 \begin{lstlisting}
 program = 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is a class page template</body></html>") >>> 
generateSnapshot "trunk" >>> 
editArtifactTree "trunk" (liftDocument $ Document "classPage" "<html><head><title>Class page</title></head><body><h1>Class page</h1><br />This is information for week 1</body></html>") >>> 
generateSnapshot "trunk" 

platform1 = Platform "platform1" (PlatformContents (liftDocument emptyDocument) (initialVersion(NumberPlaceholder) ) "")
platform2 = Platform "platform2" (PlatformContents (liftDocument emptyDocument) (initialVersion(NumberPlaceholder) ) "")

platformDB = [ platform1, platform2 ]

> deploy (program initialArtifactTree) [DeploymentRuleVersion (stringToVersion "3") "platform2"] platformDB

["platform1": x (),"platform2": 3 (),"platform3": x ()]
 \end{lstlisting}
\item Add presentation for week 1 (4th rev)
\item Add homework for week 1 (5th rev)
\item Deploy to the server
\item Add solutions for homework 1 (6th rev)
\item Deploy to the server
\item ...
\end{enumerate}

% Provide a precise description of the different outcomes of the DSL. This
% information is typically provided by Haskell function signatures (that is,
% function names and their types).

% One kind of ``outcome'' is the result of executing a DSL program. For example,
% for a scheduling DSL, an outcome would typically consist of a set of possible
% schedules. But it could also be only one schedule (the best according to some
% criterion).
%
% However, in addition to such primary outcomes, there could be other results.
% In the case of the scheduling DSL, one could imagine sending emails to
% participants asking for priorities in case several optimal schedules exist.

\section{Cognitive Dimension Evaluation}
\label{sec:cogdim}

% An assessment of cognitive dimension of your notation, such as closeness of
% mapping, viscosity, hidden dependencies, and others, will help you with the
% re-design of the DSL.

% Note that it is advisable to think about the cognitive dimensions constantly
% during the design of your DSL. Cognitive dimensions are, in fact, a language
% design tool, and not so much intended to evaluate languages after the fact.


\section{Implementation Strategy}
\label{sec:implementation}

% Discuss how the advantages and disadvantages of a deep or shallow embedding
% play out in your DSL.

% What dvantages would an implementation in a language workbench have? Is it
% worth the effort?


\section{Find Similar/Related DSLs}
\label{sec:related}

%Try to find DSLs that are similar to the one described here and compare your
% DSL with those. Note that similarity can be understood as \emph{topical} as
% well as \emph{technical} similarity .

% \emph{Topically similar} DSLs are DSLs for the same or a closely related
% domain. They have in principle the same or slightly different outcomes, but
% they may be implemented quite differently. These DSLs help you refine the
% design of the DSL requirements described in Sections \ref{sec:users} and
% \ref{sec:outcomes}.

% \emph{Technically similar} DSLs are Haskell DSLs whose types and functions are
% similar to the ones used in Sections \ref{sec:objects} and \ref{sec:comb}.
% They can help sharpen the DSL modeling and implementation described in those
% sections.

% Ideally, you can find both, topically and technically similar DSLs. Be sure to
% properly cite the DSLs as references.

% \bigskip\noindent\fbox{
% \textbf{You will have to present these DSLs in a class presentation.}}


\section{Design Evolution}
\label{sec:evol}
It seemed attractive at first to implement a DSL that provides operations only with \textit{version numbers}. But it turned out that it would be insufficient for a DSL to have such operations. As a result, DSL domain has been extended to \textit{artifact trees}. While old operators for version numbers still exist in our DSL, we have extended list of operators with a set of new operators. 

Old operators:
\begin{lstlisting}[style=Haskell]
decrement :: VersionNumber -> VersionNumber
decrementDimension :: NumberOfDimensions -> VersionNumber -> VersionNumber
increment :: VersionNumber -> VersionNumber
incrementDimension :: NumberOfDimensions -> VersionNumber -> VersionNumber
getNumberOfDimensions :: VersionNumber -> NumberOfDimensions
appendDimension :: VersionNumber -> VersionNumber
generateNewVersionNumber :: VersionNumber -> VersionNumber
incrementReleaseNumber :: VersionNumber -> VersionNumber
incrementSupportNumber :: VersionNumber -> VersionNumber
freezeExperimental :: VersionNumber -> VersionNumber
freezeRelease :: VersionNumber -> VersionNumber
freezeSupport :: VersionNumber -> VersionNumber
isExperimentalSnapshot :: VersionNumber -> Bool
isReleaseSnapshot :: VersionNumber -> Bool
isSupportSnapshot :: VersionNumber -> Bool
\end{lstlisting}

New operators:
\begin{lstlisting}[style=Haskell]
generateSnapshot :: BranchName -> ArtifactTree -> ArtifactTree
createExperimentalBranch :: BranchName -> ArtifactTree -> ArtifactTree
createReleaseBranch :: BranchName -> ArtifactTree -> ArtifactTree
createSupportBranch :: BranchName -> ArtifactTree -> ArtifactTree
editArtifactTree :: BranchName -> DocumentOrDirectory -> ArtifactTree -> ArtifactTree
deploy :: ArtifactTree -> DeploymentRules -> PlatformDB -> PlatformDB
\end{lstlisting}
% As you iterate over different designs of your DSL, it is quite instructive to
% document some of the old, obsolete designs, that is, show the type definitions
% and function signatures, explain why this design seemed attractive at first
% and then what motivated you to change it.

% This part may seem like an unnecessary burden to you, but it helps you and
% others to understand your current design, and it probably answers questions
% that users (or reviewers) of the DSL might have about the design, because they
% may have thought of your initial design also and are wondering why it has not
% been adopted.



\section{Future Work}
\label{sec:future}

A speculation about what it takes to remove some of the limitations and
whether it seems worth the effort.

Moreover, what would be the concrete benefits to extend a shallow DSL into a
deep DSL? Or, would it be helpful to create an external DSL? What role could a
visual syntax or a GUI interface play?



\section*{References}

List references to similar DSLs identified in Section \ref{sec:related} and
potentially other related work.

% argument is your BibTeX string definitions and bibliography database(s)
\bibliographystyle{plain}
%\bibliography{dsl_reportcard}

\end{document}

